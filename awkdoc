#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Features
# - [x] @arg
# - [x] @description
# - [x] @section
# - [x] @env
# - [x] @set
# - [x] @see
# - [x] @type
# - [x] @internal
# - [x] @noargs
#
#-------------------------------------------------------------------------------

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking            = false
   opts["@arg"]         = true
   opts["@env"]         = true
   opts["@set"]         = true
   opts["@type"]        = true
   opts["@section"]     = true
   opts["@description"] = true

   # "Declaring" as an array, via witchcraft.
   delete _ERRORS[0]
   delete _TYPEDEFS[0]
   delete _ENV[0]
   delete _SET[0]

   column = 0
   buffer = ""

   # gensub() format strings.
   md["h1"]   = "# &"
   md["h2"]   = "## &"
   md["h3"]   = "### &"
   md["h4"]   = "#### &"
   md["h5"]   = "##### &"
   md["link"] = "[`&`](#&)"
   md["li1"]  = "- &"_a 
   md["li2"]  = "  - &"

   # Links to format strings.
   md["toc"]     = md["h1"]
   md["types"]   = md["h1"]
   md["body"]    = md["h1"]
   md["section"] = md["h2"]
   md["fn"]      = md["h3"]
   md["sub"]     = md["h4"]

   _TYPE = ""
   _TOC  = _gensub("Contents.", md["toc"])
   _BODY = _gensub("Functions.", md["body"])
}


function reset() {
   column      = 0
   buffer_open = false
   buffer      = ""
   section     = ""

   delete fn
}


#                               I/O & debugging
#-------------------------------------------------------------------------------
function significant(level,  l,s) {
   if (level == "ERROR") l = 0
   if (level == "INFO")  l = 1
   if (level == "DEBUG") l = 2

   s = ENVIRON["AWKDOC_LOG_LEVEL"]
   if (s == "") s = 0

   return l <= s
}


function color(level) {
   if (ENVIRON["AWKDOC_NO_COLOR"]) {
      return level
   }

   if (!level) level = "INFO"
   if (level == "ERROR") return c["rd"] level c["rst"]
   if (level == "INFO")  return c["cy"] level c["rst"]
   if (level == "DEBUG") return c["cy"] level c["rst"]

   return level
}


function context(line) {
   line = sprintf("%4sln. %s: %s\n", "", FNR, line)
   line = sprintf("%4sin %s\n", "", FILENAME) line
   return line 
}


function log_error(line, text,   level) {
   level = "ERROR"
   text  = "==> " color(level) ": " text
   text  = text "\n" context(line)

   if (significant(level)) {
      push(_ERRORS, text)
   }

   panicking = true
}


function write(line, text, level) {
   text  = "==> " color(level) ": " text
   text  = text "\n" context(line)

   if (significant(level)) {
      print text > "/dev/stderr"
   }
}


function typedef_in_function(line,   msg) {
   write(line, "Cannot attach @type flag to this function.", "INFO")
}


function section_in_function(line,   msg) {
   msg = "Cannot attach @section to this function. Did you intend to add a line"
   msg = msg sprintf("\n%10sbreak after the section flag?", "")
   write(line, msg, "INFO")
}


function noargs_args_mismatch(line,  msg) {
   log_error(line, "@noargs and @arg flags are mutually exclusive.")
}


#                              text manipulation
#-------------------------------------------------------------------------------
function strip(s)  { sub(/(^\s*|\s*$)/ , "" , s) }
function lstrip(s) { sub(/^\s*/        , "" , s) }
function rstrip(s) { sub(/\s*$/        , "" , s) }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function shift(   name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function push(arr, val,   i) {
   for (i=0 ;; ++i) {
      if (! arr[i]) {
         arr[i]=val
         break
      }
   }
}


function cat(left, right) {
   if (left) {
      left = left "\n" right
   } else {
      left = right
   }
   return left
}


function empty(arr) {
   for (i in arr) return false
   return true
}


function _gensub(str, repl) {
   return gensub(".*", repl, 1, str)
}


function link(text,   monospace, _text) {
   _text = text

   text = tolower(text)
   gsub(/[^[:alnum:][:space:]_]/, "", text)
   gsub(/\s/, "-", text)

   if (monospace) {
      _text = "`" _text "`"
   }

   text = "[" _text "](#" text ")"
   return text
}


#                                 build output
#-------------------------------------------------------------------------------
function add_type(name,   t,l,f) {
   if (!_TYPE) {
      _TYPE = _gensub("Types.", md["types"])
      _TYPE = cat(_TYPE, "|type|line|file|")
      _TYPE = cat(_TYPE, "|:---|:---|:---|")
   }

   _TYPEDEFS[name] = true

   t = "`" name     "`"
   l = "`" FNR      "`"
   f = "*" FILENAME "*"
   _TYPE = cat(_TYPE, "|" t "|" l "|" f "|" )
}


function add_section(   s,t) {
   s = _gensub(section, md["section"])
   if (buffer) {
      s = cat(s, buffer "\n")
   }

   t = gensub(".*", md["li1"], 1, link(section))

   _BODY = cat(_BODY, s)
   _TOC  = cat(_TOC,  t)
}


function add_arg(name, type, desc,   arg, _type) {
   gsub(/\|/, "\\|", desc)

   if (type) {
      _type = "`" type "`"
   }

   if (_TYPEDEFS[type]) {
      _type = "[" _type "](#types)"
   }

   arg = "|`" name  "`|"  _type  "|"  desc  "|"
   push(fn["args"], arg)
}


function add_fn(name, line,   f,t,a,_a) {
   # Internal or no annotations, nothing to do.
   if (empty(fn))      return
   if (fn["internal"]) return

   # INFO if @type or @section attached to a function.
   if (typedef) typedef_in_function(line)
   if (section) section_in_function(line)

   # ERROR if both @noargs and @arg
   if (fn["noargs"] && !empty(fn["args"])) {
      noargs_args_mismatch(line)
   }

   # Function heading/location.
   f = _gensub(name, md["fn"]) "()"
   f = cat(f, "(*ln. "  FNR  ", in "  FILENAME  "*)\n")
   
   # Description.
   if (buffer) {
      f = cat(f, buffer)
   }

   # Args.
   if (fn["args"][0]) {
      f = cat(f "\n", _gensub("args", md["sub"]))
      f = cat(f, "|name|type|desc|")
      f = cat(f, "|:---|:---|:---|")

      for (a in fn["args"]) {
         f = cat(f, fn["args"][a])
      }
   }

   # Sets global variables.
   if (fn["set"][0]) {
      f = cat(f "\n", _gensub("set", md["sub"]))
      for (a in fn["set"]) {
         _a = fn["set"][a]
         _SET[_a][name] = true

         _a = _gensub("`" _a "`", md["li1"])
         f = cat(f, _a)
      }
   }

   # Uses global/environment variables.
   if (fn["env"][0]) {
      f = cat(f "\n", _gensub("uses", md["sub"]))
      for (a in fn["env"]) {
         _a = fn["env"][a]
         _ENV[_a][name] = true

         _a = _gensub("`" _a "`", md["li1"])
         f = cat(f, _a)
      }
   }

   # References to other variables.
   if (fn["see"][0]) {
      f = cat(f "\n", _gensub("see", md["sub"]))
      for (a in fn["see"]) {
         _a = link(fn["see"][a], "monospace")
         _a = gensub(".*", md["li1"],  1, _a)
         f = cat(f, _a)
      }
   }

   # Append to TOC.
   t = gensub(".*", md["li2"], 1, link(name, "monospace"))

   _TOC  = cat(_TOC,  t)
   _BODY = cat(_BODY, f "\n")
}


function build_env(   out,v,fn) {
   out = _gensub("Variables referenced.", md["h1"])

   for (v in _ENV) {
      out = cat(out, gensub(".*", md["li1"], 1, "`" v "`"))
      for (fn in _ENV[v]) {
         fn  = link(fn, "monospace")
         out = cat(out, gensub(".*", md["li2"], 1, fn))
      }
   }

   return out "\n"
}


function build_set(   out,v,fn) {
   out = _gensub("Variables set.", md["h1"])

   for (v in _SET) {
      out = cat(out, gensub(".*", md["li1"], 1, "`" v "`"))
      for (fn in _SET[v]) {
         fn  = link(fn, "monospace")
         out = cat(out, gensub(".*", md["li2"], 1, fn))
      }
   }

   return out "\n"
}


#                                   matches
#-------------------------------------------------------------------------------
# If hit an error, skip until a synchronization point--a valid @-identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


# match:  non-comment text or empty lines
#
# More flexibility when declaring a type. May put the `@type` flag at the top of
# a comment block, raerpb directly before the declaration.
#/^\s*[^#]/ || /^\s*$/ {
#   typedef = false
#}


# match:  @section
#
/^\s*#\s+@section(\s*|$)/ {
   line = $0

   sub(/^\s*#\s+@section\s*/, "")
   section = $0

   if (!section) {
      log_error(line, "Missing section title", "ERROR")
   }

   buffer_open = false
   next
}


# match:  @arg
#
/^\s*#\s+@arg\s+/ {
   line = $0

   sub(/^\s*#\s+@arg\s+/, "")
   name = shift()

   if (!name) {
      log_error(line, "Missing argument name")
      next
   }

   if (match($1, /^:[[:alpha:]_][[:alnum:]_:-]*/)) {
      sub(/^:/, "")
      type = shift()
   } else {
      type = ""
   }

   add_arg(name, type, $0)

   buffer_open = false
   next
}


# match:  @set
#
/^\s*#\s+@set\s+/ {
   sub(/^\s*#\s+@set\s+/, "")
   push(fn["set"], shift())

   buffer_open = false
   next
}


# match:  @env
#
/^\s*#\s+@env\s+/ {
   sub(/^\s*#\s+@env\s+/, "")
   push(fn["env"], shift())

   buffer_open = false
   next
}


# match:  @see
#
/^\s*#\s+@see\s+/ {
   sub(/^\s*#\s+@see\s+/, "")
   push(fn["see"], shift())

   buffer_open = false
   next
}


# match:  @internal
#
# Do not include this function, or its docs, in the generated output.
/^\s*#\s+@internal(\s+|$)/ {
   fn["internal"] = true
   next
}


# match:  @noargs
#
# Doesn't actually impact the output, just use for error reporting if an @arg
# is additionally passed.
/^\s*#\s+@noargs(\s+|$)/ {
   fn["noargs"] = true
   next
}


# match:  @description
#
# Will match text beginning on the same line, as well as the subsequent line.
# Dedents text to the level of the initial line.
match($0, /^\s*#\s+@description(\s+|$)/) {
   sub(/^\s*#\s+@description\s*/, "")
   if ($1) {
      column = RLENGTH
      buffer = $0
   }

   buffer_open = true
   next
}


# match:  @type
#
# Declares the following variable as a "type". Easier way of tracking down where
# where things have been defined.
/^\s*#\s+@type(\s+|$)/ {
   buffer_open = false
   typedef     = true
   next
}


# match:  comment line with no text
#
/^\s*#\s*$/ && buffer_open {
   buffer = buffer "\n"
   next
}


# match:  regular comment text, potentially add to buffer
#
/^\s*#/ && buffer_open {
   if (!column) {
      match($0, /^\s*#\s+/)
      column = RLENGTH
   }

   if (match($0, /^\s*#\s*/) && (column > RLENGTH)) {
      buffer_open = false
   } else {
      sub(".{" column "}", "")
      buffer = cat(buffer, $0)
   }

   next
}


# match:  unknown @-identifiers
#
/^\s*#\s+@[[:alpha:]]/ {
   line = $0
   sub(/^\s*#\s+@/, "")
   write(line, "Unknown @-flag: " shift(), "INFO")
}


#                               synchronization
#-------------------------------------------------------------------------------
# Synchronization points (all non-comment text):
#  * function declarations
#  * variable declarations
#  * non-comment text after a section (and description?) flag

# match:  function declarations, both styles
#
/^\s*function\s+[[:alpha:]_][[:alnum:]_:-]*/ ||
/^\s*[[:alpha:]_][[:alnum:]_:-]*\s*\(\s*\)/ {
   line = $0

   sub(/^\s*function/, "")
   sub(/\s*/, "")
   sub(/\(.*)/, "")

   add_fn($1, line)
   reset() ; next
}


# match:  variable declarations, for typedefs
#
typedef && (/^\s*(declare|local)/ || /\s*[[:alpha:]_][[:alnum:]_]*=/) {
   sub(/^\s*)/, "")
   sub(/^\s*(declare|local)(\s+\-(\-|[gAainxr]+))?\s*/, "")
   sub(/=.*/, "")

   add_type($1)
   typedef = false

   reset() ; next
}


# match:  non-comment text or empty lines
#         syncs section & description
#
/^\s*[^#]/ || /^\s*$/ {
   typedef = false
   if (section) add_section()
   reset() ; next
}


END {
   if (!empty(_ERRORS)) {
      for (idx in _ERRORS) {
         print _ERRORS[idx] > "/dev/stderr"
      }
      exit 1
   }

   _TOC = _TOC "\n"
   print _TOC

   if (_TYPE) _TYPE = _TYPE "\n"
   print _TYPE

   if (!empty(_ENV)) print build_env()
   if (!empty(_SET)) print build_set()

   print _BODY
   print "<br/><br/>\n:: *generated by @hre-utils/awkdoc* ::"
}
