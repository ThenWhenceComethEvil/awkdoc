#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Features
# - [x] @arg
# - [x] @description
# - [x] @section
# - [x] @env
# - [x] @sets
# - [x] @see
# - [ ] @type
# - [ ] @noargs
# - [ ] @stdin
# - [ ] @stdout
# - [ ] @stderr
# - [ ] @internal
#
#-------------------------------------------------------------------------------

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking             = false
   opts["@arg"]          = true
   opts["@env"]          = true
   opts["@sets"]         = true
   opts["@type"]         = true
   opts["@section"]      = true
   opts["@description"]  = true

   # "Declaring" typedefs[] as an array, via witchcraft.
   delete errors[0]
   delete typedefs[0]

   column = 0
   buffer = ""

   # gensub() format strings.
   md["h1"]   = "# &"
   md["h2"]   = "## &"
   md["h3"]   = "### &"
   md["h4"]   = "#### &"
   md["h5"]   = "##### &"
   md["link"] = "[`&`](#&)"
   md["li1"]  = "- &"_a 
   md["li2"]  = "  - &"

   # Links to format strings.
   md["toc"]     = md["h1"]
   md["types"]   = md["h1"]
   md["body"]    = md["h1"]
   md["section"] = md["h2"]
   md["fn"]      = md["h3"]
   md["sub"]     = md["h4"]

   _TYPE = ""
   _TOC  = _gensub("Contents.", md["toc"])
   _BODY = _gensub("Functions.", md["body"])
}


function reset() {
   column      = 0
   type        = true
   buffer_open = false
   buffer      = ""
   section     = ""

   delete fn
}


#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level) {
   if (ENVIRON["AWKDOC_NO_COLOR"]) level = ""
   if (level == 1) text = c["rd"]  "[ERROR] "  c["rst"] text
   if (level == 2) text = c["cy"]  "[DEBUG] "  c["rst"] text
   return text
}


function log_error(text, level) {
   text = "ln. "  FNR  ", "  text
   push(errors, format(text, level))
   panicking = true
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function strip(s)  { sub(/(^\s*|\s*$)/ , "" , s) }
function lstrip(s) { sub(/^\s*/        , "" , s) }
function rstrip(s) { sub(/\s*$/        , "" , s) }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function shift(   name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function push(arr, val,   i) {
   for (i=0 ;; ++i) {
      if (! arr[i]) {
         arr[i]=val
         break
      }
   }
}


function cat(left, right) {
   if (left) {
      left = left "\n" right
   } else {
      left = right
   }
   return left
}


function _gensub(str, repl) {
   return gensub(str, repl, 1, str)
}


function link(text,   monospace, _text) {
   _text = text

   text = tolower(text)
   gsub(/[^[:alnum:][:space:]_]/, "", text)
   gsub(/\s/, "-", text)

   if (monospace) {
      _text = "`" _text "`"
   }

   text = "[" _text "](#" text ")"
   return text
}


#                                 build output
#-------------------------------------------------------------------------------
function add_type(name,   t) {
   if (!_TYPE) {
      _TYPE = _gensub("Types.", md["types"])
   }

   typedefs[name] = true

   t = gensub(".*", md["li1"], 1, "`"  name  "` [_ln. "  FNR  "_]")
   _TYPE = cat(_TYPE, t)
}


function add_section(   s,t) {
   s = _gensub(section, md["section"])
   if (buffer) {
      s = cat(s, buffer "\n")
   }

   t = gensub(".*", md["li1"], 1, link(section))

   _BODY = cat(_BODY, s)
   _TOC  = cat(_TOC,  t)
}


function add_arg(name, type, desc,   arg, _type) {
   gsub(/\|/, "\\|", desc)

   _type = "`" type "`"
   if (typedefs[type]) {
      _type = "[" _type "](#types)"
   }

   arg = "|" name  "|"  _type  "|"  desc  "|"
   push(fn["args"], arg)
}


function add_fn(name,  f,t,a,_a) {
   # Function heading/location.
   f = _gensub(name, md["fn"])
   f = cat(f, "[_ln. "  FNR  ", in "  FILENAME  "_]\n")
   
   # Description.
   if (buffer) {
      f = cat(f, buffer)
   }

   # Args.
   if (fn["args"][0]) {
      f = cat(f "\n", _gensub("args", md["sub"]))
      f = cat(f, "|name|type|desc|")
      f = cat(f, "|:---|:---|:---|")

      for (a in fn["args"]) {
         f = cat(f, fn["args"][a])
      }
   }

   # Sets global variables.
   if (fn["sets"][0]) {
      f = cat(f "\n", _gensub("sets", md["sub"]))
      for (a in fn["sets"]) {
         _a = "`" fn["sets"][a] "`"
         _a = _gensub(_a, md["li1"])
         f = cat(f, _a)
      }
   }

   # Uses global/environment variables.
   if (fn["env"][0]) {
      f = cat(f "\n", _gensub("uses", md["sub"]))
      for (a in fn["env"]) {
         _a = "`" fn["env"][a] "`"
         _a = _gensub(_a, md["li1"])
         f = cat(f, _a)
      }
   }

   # References to other variables.
   if (fn["see"][0]) {
      f = cat(f "\n", _gensub("see", md["sub"]))
      for (a in fn["see"]) {
         _a = link(fn["see"][a], "monospace")
         _a = gensub(".*", md["li1"],  1, _a)
         f = cat(f, _a)
      }
   }

   # Append to TOC.
   t = gensub(".*", md["li2"], 1, link(name, "monospace"))

   _TOC  = cat(_TOC,  t)
   _BODY = cat(_BODY, f "\n")
}


#                                   matches
#-------------------------------------------------------------------------------
# Must always be the first match. If hit an error, skip until a synchronization
# point--a valid @-identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


# match:  @section
#
/^\s*#\s+@section(\s*|$)/ {
   sub(/^\s*#\s+@section\s*/, "")
   section = $0

   if (! section) {
      log_error("Missing section title", 1)
   }

   buffer_open = false
   next
}


# match:  @arg
#
/^\s*#\s+@arg\s+/ {
   sub(/^\s*#\s+@arg\s+/, "")
   name = shift()

   if (match($1, /^:[[:alpha:]_][[:alnum:]_:-]*/)) {
      sub(/^:/, "")
      type = shift()
   } else {
      type = ""
   }

   add_arg(name, type, $0)

   buffer_open = false
   next
}


# match:  @sets
#
/^\s*#\s+@sets\s+/ {
   sub(/^\s*#\s+@sets\s+/, "")
   push(fn["sets"], shift())

   buffer_open = false
   next
}


# match:  @env
#
/^\s*#\s+@env\s+/ {
   sub(/^\s*#\s+@env\s+/, "")
   push(fn["env"], shift())

   buffer_open = false
   next
}


# match:  @see
#
/^\s*#\s+@see\s+/ {
   sub(/^\s*#\s+@see\s+/, "")
   push(fn["see"], shift())

   buffer_open = false
   next
}


# match:  @description
#
# Will match text beginning on the same line, as well as the subsequent line.
# Dedents text to the level of the initial line.
match($0, /^\s*#\s+@description(\s+|$)/) {
   sub(/^\s*#\s+@description\s*/, "")
   if ($1) {
      column = RLENGTH
      buffer = $0
   }

   buffer_open = true
   next
}


# match:  @type
#
# Declares the following variable as a "type". Easier way of tracking down where
# where things have been defined.
/^\s*#\s+@type\s+/ {
   buffer_open = false
   type        = true
   next
}


# match:  comment line with no text
#
/^\s*#\s*$/ && buffer_open {
   buffer = buffer "\n"
   next
}


# match:  regular comment text, potentially add to buffer
#
/^\s*#/ && buffer_open {
   if (!column) {
      match($0, /^\s*#\s+/)
      column = RLENGTH
   }

   if (match($0, /^\s*#\s*/) && (column > RLENGTH)) {
      buffer_open = false
   } else {
      sub(".{" column "}", "")
      buffer = cat(buffer, $0)
   }

   next
}


#                               synchronization
#-------------------------------------------------------------------------------
# Synchronization points (all non-comment text):
#  * function declarations
#  * variable declarations
#  * non-comment text after a section (and description?) flag

# match:  function declarations, both styles
#
/^\s*function\s+[[:alpha:]_][[:alnum:]_:-]*/ ||
/^\s*[[:alpha:]_][[:alnum:]_:-]*\s*\(\s*\)/ {
   sub(/^\s*function/, "")
   sub(/\s*/, "")
   sub(/\(.*)/, "")

   add_fn($1)
   reset() ; next
}


# match:  variable declarations, for typedefs
#
type && /\s*(declare|local)/ {
   sub(/\s*(declare|local)(\s+\-(\-|[gAainxr]+))?\s*/, "")
   add_type($1)
   reset() ; next
}
type && /\s*[[:alpha:]_][[:alnum:]_]*=/ {
   sub(/^\s*)/, "")
   sub(/=.*$/, "")
   add_type($1)
   reset() ; next
}


# match:  non-comment text or empty lines
#         syncs section & description
#
/^\s*[^#]/ || /^\s*$/ {
   if (section) add_section()
   reset() ; next
}


END {
   # len(errors) is gawk-only, this is universal.
   if (errors[0]) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }

   _TOC = _TOC "\n"
   print _TOC

   if (_TYPE) _TYPE = _TYPE "\n"
   print _TYPE

   print _BODY
}
