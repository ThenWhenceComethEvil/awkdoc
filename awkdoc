#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Features
# - [x] @arg
# - [x] @description
# - [x] @section
# - [ ] @env
# - [ ] @sets
# - [ ] @type
# - [ ] @noarg
# - [ ] @see
# - [ ] @stdin
# - [ ] @stdout
# - [ ] @stderr
# - [ ] @internal
#
#-------------------------------------------------------------------------------
# Thinkies
# Might need to rework syntax. Can be annoying to tell what comments are part
# of an existing multiline block, or irrelevant. Maybe common prefix for things?
#       #|arg  $1  <type>  <desc>
#       #|sets $1
#       #|description
#       #|  Here's a block of text that's clearly attached
#       #|  to the description
#       # And this very much is not attached to the above.
#       #
#       #> Here's a block to wrap in a  ```bash ... ```
#
# Really it's just the start/end of multiline blocks that's confusing. Maybe
# need to only match on text that meets the indentation level.
#> indent = "#\s{" column -1 "}"
#> if match($0, indent) { ... }
#
# Can't only do it indentation based, or a comment like this would be caught:
#> @description
#>   beep boop here's a line
#> this won't be in the output
#>   but this would!
#
#-------------------------------------------------------------------------------

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking             = false
   opts["@arg"]          = true
   opts["@description"]  = true

   # "Declaring" errors[] as an array, via witchcraft.
   delete errors[0]

   column = 0
   buffer = ""

   # gensub() format strings.
   md["h1"]   = "# &"
   md["h2"]   = "## &"
   md["h3"]   = "### &"
   md["h4"]   = "#### &"
   md["h5"]   = "##### &"
   md["link"] = "[&](#&)"
   md["li1"]  = "- &"_a 
   md["li2"]  = "  - &"

   # Links to format strings.
   md["toc"]     = md["h1"]
   md["body"]    = md["h1"]
   md["section"] = md["h2"]
   md["fn"]      = md["h3"]
   md["sub"]     = md["h4"]

   _TOC  = _gensub("Contents.", md["toc"])
   _BODY = _gensub("Functions.", md["body"])
}


function reset() {
   column      = 0
   buffer_open = false
   buffer      = ""
   section     = ""

   delete fn
}


#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level) {
   if (ENVIRON["AWKDOC_NO_COLOR"]) level = ""
   if (level == "CRIT")  text = c["rd"]  "[CRIT] "  c["rst"] text
   if (level == "WARN")  text = c["yl"]  "[WARN] "  c["rst"] text
   if (level == "INFO")  text = c["cy"]  "[INFO] "  c["rst"] text
   if (level == "DEBUG") text = c["cy"]  "[DBUG] "  c["rst"] text
   return text
}


function log_error(text, level) {
   text = "ln. "  FNR  ", "  text
   push(errors, format(text, level))
   panicking = true
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function strip(s)  { sub(/(^\s*|\s*$)/ , "" , s) }
function lstrip(s) { sub(/^\s*/        , "" , s) }
function rstrip(s) { sub(/\s*$/        , "" , s) }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function shift(   name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function push(arr, val,   i) {
   for (i=0 ;; ++i) {
      if (! arr[i]) {
         arr[i]=val
         break
      }
   }
}


function cat(left, right) {
   if (left) {
      left = left "\n" right
   } else {
      left = right
   }
   return left
}


function _gensub(str, repl) {
   return gensub(str, repl, 1, str)
}


#                                 build output
#-------------------------------------------------------------------------------
function add_section(   s, t) {
   s = _gensub(section, md["section"])
   if (buffer) {
      s = cat(s, buffer "\n")
   }

   t = _gensub(section, md["link"])
   t = gensub(".*", md["li1"], 1, t)

   _BODY = cat(_BODY, s)
   _TOC  = cat(_TOC,  t)
}


function add_arg(name, type, desc,   arg) {
   gsub(/\|/, "\\|", desc)
   arg = "|" name "|" type "|" desc "|"
   push(fn["args"], arg)
}


function add_fn(name,  f,t,a,_a) {
   # Function heading/location.
   f = _gensub(name, md["fn"])
   f = cat(f, "[_ln. "  FNR  ", in "  FILENAME  "_]\n")
   
   # Description.
   if (buffer) {
      f = cat(f, buffer)
   }

   # Args.
   if (fn["args"][0]) {
      f = cat(f "\n", _gensub("args", md["sub"]))
      f = cat(f, "|name|type|desc|")
      f = cat(f, "|:---|:---|:---|")

      for (a in fn["args"]) {
         f = cat(f, fn["args"][a])
      }
   }

   # Sets global variables.
   if (fn["sets"][0]) {
      f = cat(f "\n", _gensub("sets", md["sub"]))
      for (a in fn["sets"]) {
         _a = "`" fn["sets"][a] "`"
         _a = _gensub(_a, md["li1"])
         f = cat(f, _a)
      }
   }

   # Uses global/environment variables.
   if (fn["env"][0]) {
      f = cat(f "\n", _gensub("uses", md["sub"]))
      for (a in fn["env"]) {
         _a = _gensub(fn["sets"][a], md["li1"])
         f = cat(f, "`" _a "`")
      }
   }

   # Append to TOC.
   t = _gensub(name, md["link"])
   t = gensub(".*", md["li2"], 1, t)

   _TOC  = cat(_TOC,  t)
   _BODY = cat(_BODY, f "\n")
}


function add_sets(name) {
   push(fn["sets"], name)
}


function add_env(name) {
   push(fn["env"], name)
}


#                                   matches
#-------------------------------------------------------------------------------
# Must always be the first match. If hit an error, skip until a synchronization
# point--a valid @-identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


# match:  @section
#
/^\s*#\s+@section\s+/ {
   sub(/^\s*#\s+@section\s+/, "")
   section = $0
   next
}


# match:  @arg
#
/^\s*#\s+@arg\s+/ {
   sub(/^\s*#\s+@arg\s+/, "")
   name = shift()

   if (match($1, /^:[[:alpha:]_][[:alnum:]_:-]*/)) {
      sub(/^:/, "")
      type = shift()
   } else {
      type = ""
   }

   add_arg(name, type, $0)
   next
}


# match:  @sets
#
/^\s*#\s+@sets\s+/ {
   sub(/^\s*#\s+@sets\s+/, "")
   add_sets(shift())
   next
}


# match:  @env
#
/^\s*#\s+@env\s+/ {
   sub(/^\s*#\s+@env\s+/, "")
   add_env(shift())
   next
}


# match:  @description
#
# Will match text beginning on the same line, as well as the subsequent line.
# Dedents text to the level of the initial line.
match($0, /^\s*#\s+@description(\s+|$)/) {
   sub(/^\s*#\s+@description\s*/, "")
   if ($1) {
      column = RLENGTH
      buffer = $0
   }

   buffer_open = true
   next
}


# match:  comment line with no text
#
/^\s*#\s*$/ && buffer_open {
   buffer = buffer "\n"
   next
}


# match:  regular comment text, potentially add to buffer
#
/^\s*#/ && buffer_open {
   if (!column) {
      match($0, /^\s*#\s+/)
      column = RLENGTH
   }

   if (match($0, /^\s*#\s*/) && (column > RLENGTH)) {
      buffer_open = false
   } else {
      sub(".{" column "}", "")
      buffer = cat(buffer, $0)
   }

   next
}


#                               synchronization
#-------------------------------------------------------------------------------
# Synchronization points (all non-comment text):
#  * function declarations
#  * variable declarations
#  * non-comment text after a section (and description?) flag

# match:  function declarations, both styles
#
/^\s*function\s+[[:alpha:]_][[:alnum:]_:-]*/ ||
/^\s*[[:alpha:]_][[:alnum:]_:-]*\s*\(\s*\)/ {
   sub(/^\s*function/, "")
   sub(/\s*/, "")
   sub(/\(.*)/, "")

   add_fn($1)
   reset() ; next
}


# match:  non-comment text or empty lines
#         syncs section & description
#
/^\s*[^#]/ || /^\s*$/ {
   if (section) add_section()
   reset() ; next
}


## match:  variable declarations, for typedefs
##
#typedef && /\s*(declare|local)\s+(-(-|[gAainxr]+))\s+[[:alpha:]_]/ {
#   sub(/\s*(declare|local)\s+(-(-|[gAainxr]+))\s+/, "")
#   reset() ; next
#}
#typedef && /\s*[[:alpha:]_][[:alnum:]_]*=/ {
#   sub(/\s*/, "")
#   reset() ; next
#}


END {
   # len(errors) is gawk-only, this is universal.
   if (errors[0]) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }

   _TOC = _TOC  "\n"
   print _TOC
   print _BODY
}
