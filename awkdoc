#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#
# It would be trivial to write this in bash. Will likely make a bash version
# down the line. However I've wanted to learn more "advanced" AWK for a great
# long while. This is a good project to do so.
#
# Attempting something to build documentation from comments. Javadoc style. Not
# too sure on the format I'm going with. Probably going to mirror very similar
# functionality from shdoc.
#
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear. Seems like
   # these use the same rules as (( ... )) tests in bash.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking      = false
   opts["@arg"]   = true
   opts["@does"]  = true

   # Determining if we're in a multiline string.
   column = 0

   # Temporary buffers.
   tmp_arg  = ""           # Function arguments.
   tmp_does = ""           # What a function does.
   tmp_fn   = ""

   # Hacky way of 'declaring' an array:
   delete errors[0]
}

#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level,   color) {
   if (level == "CRIT" )  text = "["  c["rd"]  "CRIT"  c["rst"]  "] "  text
   if (level == "WARN" )  text = "["  c["yl"]  "WARN"  c["rst"]  "] "  text
   if (level == "INFO" )  text = "["  c["cy"]  "INFO"  c["rst"]  "] "  text
   if (level == "DEBUG")  text = "["  c["cy"]  "DBUG"  c["rst"]  "] "  text
   return text
}


function log_error(text, level) {
   text = "ln. "  NR  ", "  text
   text = format(text, level)
   push(errors, text)
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function lstrip() { sub(/^\s*/, "") }
function rstrip() { sub(/\s*$/, "") }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function pop_word(name) {
   name = $1
   sub(/[^[:space:]]*[[:space:]]*/, "")
   return name
}


function pop_type(type) {
   # Typedefs must be surrounded by parens.
   if (! match($1, /\([[:alpha:]_][[:alnum:]_]*\)/ )) {
      panicking = true
      log_error("arg typedef should be in parentheses.", "WARN")
      next
   }

   # Pop first word from stack, remove surrounding parens.
   type = pop_word()
   sub(/^\(/, "", type) ; sub(/\)$/, "", type)
   return type
}

#                                  utilities
#-------------------------------------------------------------------------------
function reset() {
   cursor   = 0
   tmp_arg  = ""
   tmp_does = ""
   tmp_fn   = ""
}


function push(arr, item) {
   arr[length(arr)+1] = item
}

#                                 build output
#-------------------------------------------------------------------------------
function build_function(name,   idx) {
   print tmp_arg
   reset() ; next
}


function build_arg(name, type, desc) {
   type = gensub(type, "([&](#Types#&))", 1, type)

   if (tmp_arg)
      tmp_arg = tmp_arg "\n"

   tmp_arg = tmp_arg "- *" name "* "  type  " "  desc
}

#                                   matches
#-------------------------------------------------------------------------------
# This should always be the first match.
#
# When hitting an error, start skipping lines until we hit a new synchronization
# point--a valid @identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


match($0, /^\s*#\s+@arg\s+/) {
   cursor = cursor + RLENGTH - 1
   sub(/^\s*#\s+@arg\s+/, "")

   name = pop_word()
   type = pop_type()
   desc = $0

   build_arg(name, type, desc)
}


# match:  function foo {
# match:  foo() {
#
# Functions can be declared in bash either with the function keyword, or with
# the literal syntax identifier + () + {...}.
/^\s*function\s+[[:alpha:]][[:alnum:]_:\.]*\s*(\(\))?\s*\{/ ||
/^\s*[[:alpha:]][[:alnum:]_:\.]*\s*\(\)\s*\{/ {
   # In case of the former option, remove leading `function' keyword.
   sub(/^\s*function/, "")

   name = $1
   sub(/\(\)/, "", name)
   sub(/\{$/,  "", name)

   build_function(name)
}


# Non comment text. Reset temporary buffers.
/^\s*[^#]/ {
   reset()
}


END {
   if (isarray(errors)) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }
}
