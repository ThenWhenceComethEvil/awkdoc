#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Features
# - [x] @arg
# - [x] @description
# - [ ] @type
# - [ ] @noarg
# - [ ] @section
# - [ ] @see
# - [ ] @stdin
# - [ ] @stdout
# - [ ] @stderr
# - [ ] @internal
# - [ ] @env
# - [ ] @sets
#
#-------------------------------------------------------------------------------
# Thinkies
# Might need to rework syntax. Can be annoying to tell what comments are part
# of an existing multiline block, or irrelevant. Maybe common prefix for things?
#       #|arg  $1  <type>  <desc>
#       #|sets $1
#       #|description
#       #|  Here's a block of text that's clearly attached
#       #|  to the description
#       # And this very much is not attached to the above.
#       #
#       #> Here's a block to wrap in a  ```bash ... ```
#
# Really it's just the start/end of multiline blocks that's confusing. Maybe
# need to only match on text that meets the indentation level.
#> indent = "#\s{" column -1 "}"
#> if match($0, indent) { ... }
#
#-------------------------------------------------------------------------------

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking             = false
   opts["@arg"]          = true
   opts["@description"]  = true

   # "Declaring" errors[] as an array, via witchcraft.
   delete errors[0]

   column = 0
   buffer = ""

   # gensub() format strings.
   md["h1"]   = "# &"
   md["h2"]   = "## &"
   md["h3"]   = "### &"
   md["h4"]   = "#### &"
   md["h5"]   = "##### &"
   md["link"] = "[&](#&)"

   # Links to format strings.
   md["toc"]     = md["h1"]
   md["body"]    = md["h1"]
   md["section"] = md["h2"]
   md["fn"]      = md["h3"]
   md["args"]    = md["h4"]

   _TOC  = ""
   _BODY = ""
}

#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level) {
   if (ENVIRON["AWKDOC_NO_COLOR"]) level = ""
   if (level == "CRIT")  text = c["rd"]  "[CRIT] "  c["rst"] text
   if (level == "WARN")  text = c["yl"]  "[WARN] "  c["rst"] text
   if (level == "INFO")  text = c["cy"]  "[INFO] "  c["rst"] text
   if (level == "DEBUG") text = c["cy"]  "[DBUG] "  c["rst"] text
   return text
}


function log_error(text, level) {
   text = "ln. "  FNR  ", "  text
   push(errors, format(text, level))
   panicking = true
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function lstrip() { sub(/^\s*/, "") }
function rstrip() { sub(/\s*$/, "") }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function shift(   name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function push(key, val) {
   key[length(key)+1] = val
}


function cat(left, right) {
   if (left) {
      left = left "\n" right
   } else {
      left = right
   }
   return left
}


function _gensub(str, repl) {
   return gensub(str, repl, 1, str)
}

#                                  utilities
#-------------------------------------------------------------------------------
function reset() {
   column = 0
   buffer = ""
   delete fn
}

#                                 build output
#-------------------------------------------------------------------------------
function add_arg(name, type, desc,   arg) {
   gsub(/\|/, "\\|", desc)
   arg = "|" name "|" type "|" desc "|"
   push(fn["args"], arg)
}


function add_fn(name,  _f) {
   # Function heading.
   _f = cat(_f, _gensub(name, md["fn"]))

   # Location.
   _f = cat(_f, "ln. "  FNR  ", in "  FILENAME  "\n")
   
   # Description.
   _f = cat(_f, buffer "\n")

   # Args heading.
   _f = cat(_f, _gensub("args", md["args"]))

   # Args table.
   _f = cat(_f, "|name|type|desc|")
   _f = cat(_f, "|----|----|----|")
   for (a in fn["args"]) {
      _f = cat(_f, fn["args"][a])
   }
   _f = _f "\n"

   _BODY = cat(_BODY, _f)
}


function add_section(name,   _s) {
   _s = cat(_s, _gensub(name, md["section"]))
   if (buffer) _s = cat(_s, buffer "\n")
   _BODY = cat(_BODY, _s)
}

#                                   matches
#-------------------------------------------------------------------------------
# Must always be the first match. If hit an error, skip until a synchronization
# point--a valid @-identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


# match: @section
#
/^\s*#\s+@section/ {
   sub(/^\s*#\s+@section\s*/, "")
   add_section(shift())
   next
}


# match:  @arg
#
/^\s*#\s+@arg/ {
   sub(/^\s*#\s+@arg\s*/, "")

   name = shift()

   if (match($1, /^:[[:alpha:]_][[:alnum:]_:-]*/)) {
      sub(/^:/, "")
      type = shift()
   } else {
      type = ""
   }

   add_arg(name, type, $0)
   next
}


# match: @description
#
# Will match text beginning on the same line, as well as the subsequent line.
# Dedents text to the level of the initial line.
match($0, /^\s*#\s+@description\s*/) {
   sub(/^\s*#\s+@description\s*/, "")

   if ($1) {
      column = RLENGTH
      buffer = $0
   }

   next
}


# match: regular comment text
#
# TODO: Allow for empty lines in output.
#       Currently all lines that are just /^#/ don't show up in the output.
/^\s*#\s+[^$]/ {
   if (column == 0) {
      match($0, /^\s*#\s+/)
      column = RLENGTH
   }

   # Shift off column# characters.
   sub(".{" column "}", "")
   buffer = cat(buffer, $0)

   next
}


/^\s*#\s*$/ {
   next
}


# match:  function declarations, both styles
#
/^\s*function\s+[[:alpha:]_][[:alnum:]_:-]*/ ||
/^\s*[[:alpha:]_][[:alnum:]_:-]*\s*\(\s*\)/ {
   sub(/^\s*function/, "")
   sub(/\s*/, "")
   sub(/\(.*)/, "")

   add_fn($1)
   reset() ; next
}


# match:  non-comment text, empty lines
/^\s*[^#]/ || /^\s*$/ { reset() }


END {
   if (length(errors) > 0) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }

   print _BODY
}
