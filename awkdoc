#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#
# It would be trivial to write this in bash. Will likely make a bash version
# down the line. However I've wanted to learn more "advanced" AWK for a great
# long while. This is a good project to do so.
#
# Attempting something to build documentation from comments. Javadoc style. Not
# too sure on the format I'm going with. Probably going to mirror very similar
# functionality from shdoc.
#
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Some notes on things I'd want:
#
# @type        Declare something as a "type", hyperlink other references to
#              types (in functions and whatnot) to the declared type. Helps
#              to build a 'map' of where everything is used.
# @arg         Declares an argument to a function by the name it's referred
#              to as within the function, and its type.
# @notes       Additional notes about implementation, things to look out for
# @description Same as shdoc
# @noarg       Same as shdoc
# @section     Same as shdoc
# @see         Same as shdoc
# @stdin       Same as shdoc
# @stdout      Same as shdoc
# @stderr      Same as shdoc
# @internal    Same as shdoc
# @env         Same as shdoc
# @sets        Same as shdoc
#
# Reference the file & line number in the generated output.
#
#-------------------------------------------------------------------------------
# THINKIES
#
# Iterating line-by-line. Each line is either:
#  1. A comment beginning with a flag  (@arg, @description, etc.)
#  2. A synchronization point (non-comment function declaration)
#  3. Multi-line addition to an immediately previous flag
#  4. None of the above (non-comment line, empty comment line, regular comment)
#
# Effectively, need to determine what category this line falls under. Append it
# to the string buffer holding that thing (or an array?).
# Hit synchronization point to build the overall output, unset the mini buffers.
#
# All flags must call `next` at the end of their body.
# All sync points must call `next` at the end of their body.
# Any remaining comment text is appended to the buffer.
#
# Can do links to functions within sections via `sections[]` map. Set a _SECTION
# variable tracking whatever section we're currently in. If unset, don't map the
# function. For @see references can do `path = '#' + s when s = sections[fn]`.

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking             = false
   opts["@arg"]          = true
   opts["@description"]  = true

   # "Declaring" errors[] as an array, via witchcraft.
   delete errors[0]

   column = 0
   buffer = ""

   # gensub() format strings.
   md["h1"]   = "# &"
   md["h2"]   = "## &"
   md["h3"]   = "### &"
   md["h4"]   = "#### &"
   md["h5"]   = "##### &"
   md["link"] = "[&](#&)"

   # Links to format strings.
   md["toc"]     = md["h1"]
   md["body"]    = md["h1"]
   md["section"] = md["h2"]
   md["fn"]      = md["h3"]
   md["args"]    = md["h4"]

   _TOC  = ""
   _BODY = ""
}

#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level) {
   if (ENVIRON["AWKDOC_NO_COLOR"]) level = ""
   if (level == "CRIT")  text = c["rd"]  "[CRIT] "  c["rst"] text
   if (level == "WARN")  text = c["yl"]  "[WARN] "  c["rst"] text
   if (level == "INFO")  text = c["cy"]  "[INFO] "  c["rst"] text
   if (level == "DEBUG") text = c["cy"]  "[DBUG] "  c["rst"] text
   return text
}


function log_error(text, level) {
   text = "ln. "  NR  ", "  text
   push(errors, format(text, level))
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function lstrip() { sub(/^\s*/, "") }
function rstrip() { sub(/\s*$/, "") }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function shift(   name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function push(key, val) {
   key[length(key)+1] = val
}


function cat(str, text) {
   if (str) {
      str = str "\n" text
   } else {
      str = text
   }
   return str
}


function _gensub(str, repl) {
   return gensub(str, repl, 1, str)
}

#                                  utilities
#-------------------------------------------------------------------------------
function reset() {
   column = 0
   buffer = ""
   delete fn
}


function add_arg(name, type, desc,   arg) {
   gsub(/\|/, "\\|", desc)
   arg = "|" name "|" type "|" desc "|"
   push(fn["args"], arg)
}


function add_fn(name,  _f) {
   # Function heading.
   _f = cat(_f, _gensub(name, md["fn"]))
   
   # Description.
   _f = cat(_f, buffer "\n")

   # Args heading.
   _f = cat(_f, _gensub("args", md["args"]))

   # Args table.
   _f = cat(_f, "|name|type|desc|")
   _f = cat(_f, "|----|----|----|")
   for (a in fn["args"]) {
      _f = cat(_f, fn["args"][a])
   }
   _f = _f "\n"

   _BODY = cat(_BODY, _f)
}

#                                 build output
#-------------------------------------------------------------------------------

#                                   matches
#-------------------------------------------------------------------------------
# This should always be the first match.
#
# When hitting an error, start skipping lines until we hit a new synchronization
# point--a valid @-identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


/^\s*#\s+@arg/ {
   sub(/^\s*#\s+@arg\s*/, "")

   name = shift()

   if (match($1, /^:[[:alpha:]_][[:alnum:]_:-]*/)) {
      sub(/^:/, "")
      type = shift()
   } else {
      type = ""
   }

   add_arg(name, type, $0)
   next
}


match($0, /^\s*#\s+@description\s*/) {
   sub(/^\s*#\s+@description\s*/, "")

   if ($1) {
      column = RLENGTH
      buffer = $0
   }

   next
}


/^\s*#\s+[^$]/ {
   if (column == 0) {
      match($0, /^\s*#\s+/)
      column = RLENGTH
   }

   # Shift off column# characters.
   sub(".{" column "}", "")
   buffer = cat(buffer, $0)
}


/^\s*#\s*$/ {
   next
}


# match:  function declarations
/^\s*function\s+[[:alpha:]_][[:alnum:]_:-]*/ ||
/^\s*[[:alpha:]_][[:alnum:]_:-]*\s*\(\s*\)/ {
   sub(/^\s*function/, "")
   sub(/\s*/, "")
   sub(/\(.*)/, "")

   add_fn($1)
   reset() ; next
}


/^[^#]/ && /^\s+[^#]/ {
   reset()
}


END {
   if (length(errors) > 0) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }

   print _BODY
}
