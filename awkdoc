#!/usr/bin/awk -f
# vim: ft=awk tw=80 sw=3 ts=3 sts=3
#
# It would be trivial to write this in bash. Will likely make a bash version
# down the line. However I've wanted to learn more "advanced" AWK for a great
# long while. This is a good project to do so.
#
# Attempting something to build documentation from comments. Javadoc style. Not
# too sure on the format I'm going with. Probably going to mirror very similar
# functionality from shdoc.
#
#-------------------------------------------------------------------------------
# ref.
# [0] https://github.com/reconquest/shdoc
# [1] https://www.math.utah.edu/docs/info/gawk_12.html
# [2] https://www.gnu.org/software/gawk/manual/html_node/Multidimensional.html
# [3] https://www.gnu.org/software/gawk/manual/html_node/Arrays-of-Arrays.html
# [4] https://www.gnu.org/software/gawk/manual/html_node/Variable-Scope.html
# [5] https://www.math.utah.edu/docs/info/gawk_13.html
#
#-------------------------------------------------------------------------------
# Some notes on things I'd want:
#
# @notes       Additional notes about implementation, things to look out for
# @type        Declare something as a "type", hyperlink other references to
#              types (in functions and whatnot) to the declared type. Helps
#              to build a 'map' of where everything is used.
# @arg         Declares an argument to a function by the name it's referred
#              to as within the function, and its type.
# @noarg       Same as shdoc
# @section     Same as shdoc
# @see         Same as shdoc
# @stdin       Same as shdoc
# @stdout      Same as shdoc
# @stderr      Same as shdoc
# @internal    Same as shdoc
# @does        Same as shdoc's @description
# @global:r    Global variables READ
# @global:w    Global variables SET
# @global:rw   Global variables UPDATE
#
# Maybe actually build an html doc, if possible, instead of a .md doc. Still
# similar to produce, yes easier to open in any browser.
#
#-------------------------------------------------------------------------------
# TODO
#  - [ ] Create pointer to reference the current section:  `current_section`?
#
#-------------------------------------------------------------------------------
# THINKIES
#
# Iterating line-by-line. Each line is either:
#  1. A comment beginning with a flag  (@arg, @does, etc.)
#  2. A synchronization point (non-comment function declaration)
#  3. Multi-line addition to an immediately previous flag
#  4. None of the above (non-comment line, empty comment line, regular comment)
#
# Effectively, need to determine what category this line falls under. Append it
# to the string buffer holding that thing (or an array?).
# Hit synchronization point to build the overall output, unset the mini buffers.

BEGIN {
   # Color escapes. For pretty-printing debugging & error information.
   c["rst"] = "\033[0m"
   c["rd"]  = "\033[31;1m"
   c["yl"]  = "\033[33;1m"
   c["cy"]  = "\033[35m"

   # Convenience variables to make boolean assignments more clear.
   false = 0
   true  = 1

   # Upon hitting an error, "panic" until the start of a next valid opt.
   panicking      = false
   opts["@arg"]   = true
   opts["@does"]  = true
}

#                               I/O & debugging
#-------------------------------------------------------------------------------
function format(text, level) {
   switch (level) {
      case "CRIT":   text = c["rd"]  "[CRIT] "  c["rst"] text
      case "WARN":   text = c["yl"]  "[WARN] "  c["rst"] text
      case "INFO":   text = c["cy"]  "[INFO] "  c["rst"] text
      case "DEBUG":  text = c["cy"]  "[DBUG] "  c["rst"] text
   }
   return text
}


function log_error(text, level) {
   text = "ln. "  NR  ", "  text
   text = format(text, level)
   push(errors, text)
}


function write(text, level) {
   print format(text, level) > "/dev/stderr"
}


#                              text manipulation
#-------------------------------------------------------------------------------
function lstrip() { sub(/^\s*/, "") }
function rstrip() { sub(/\s*$/, "") }

# Pops the first word of the current line. Removes preceding whitespace before
# and after the .pop()
function pop_word(name) {
   name = $1
   sub(/^[[:space:]]*[^[:space:]]*[[:space:]]*/, "")
   return name
}


function pop_type(type) {
   # Typedefs must be surrounded by parens.
   if (! match($1, /\([[:alpha:]_][[:alnum:]_]*\)/)) {
      panicking = true
      log_error("arg typedef should be in parentheses.", "WARN")
      next
   }

   # Pop first word from stack, remove surrounding parens.
   type = pop_word()
   sub(/^\(/, "", type) ; sub(/\)$/, "", type)
   return type
}


function push(arr, item) {
    arr[length(arr)+1] = item
}

#                                  utilities
#-------------------------------------------------------------------------------

# Need to think about the below function more. Will need an easy way of shifting
# the "columns" indicator to the right. It's more a measure of the column, raer
# than the "indentation". Easier way of thinking about it.
#
#function set_indentation(spaces,   n) {
#   match($0, /^\s/)
#   n = (spaces + RLENGTH - 2)
#   indentation = "^#[[:space:]]{" n "}"
#}

#                                 build output
#-------------------------------------------------------------------------------

#                                   matches
#-------------------------------------------------------------------------------
# This should always be the first match.
#
# When hitting an error, start skipping lines until we hit a new synchronization
# point--a valid @identifier.
panicking && /^\s*#/ {
   if (opts[$2]) {
      panicking = false
   } else {
      next
   }
}


END {
   if (isarray(errors)) {
      for (idx in errors) {
         print errors[idx] > "/dev/stderr"
      }
      exit 1
   }
}
